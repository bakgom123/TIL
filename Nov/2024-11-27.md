## 날짜: 2024-11-27

### 스크럼
- 학습 목표 : Redis 딥다이브

### 새로 배운 내용
## **Redis란?**

Redis(Remote Dictionary Server)는 인메모리 데이터 구조 스토어로, 데이터베이스, 캐시, 메시지 브로커, 대기열로 사용될 수 있는 오픈소스 소프트웨어입니다. 

가장 큰 특징은 모든 데이터를 메모리에 저장하여 처리한다는 점입니다.

## **인메모리 데이터 구조**

일반적인 데이터베이스의 작동 방식에 대해서 먼저 알아야겠죠?

분명 MySQL, PostgresSQL 등 일반적인 데이터베이스도 메모리를 사용하지만 주된 저장소는 디스크입니다.

데이터를 영구적으로 보관하기 위해 디스크에 기록하고, 자주 사용하는 일부 데이터만 메모리에 캐시로 저장합니다.

반면 Redis는 인메모리 데이터 구조를 가지고 있어서 모든 데이터를 처음부터 메모리에 저장합니다. 디스크는 백업용으로만 사용됩니다.

그래서 데이터를 읽을 때 디스크 접근이 필요 없습니다.

### Redis의 데이터 저장

1. 메모리 저장 (주 저장소)
    1. 모든 데이터는 메모리에 저장되어 있음
    2. 실제 작업은 모두 메모리에서 이루어짐
    3. 그래서 빠른 속도로 처리가 가능함
2. 디스크 저장 (백업)
    1. 서버가 갑자기 종료되어도 데이터를 복구할 수 있게 하는 안전장치
    2. Redis는 디스크에 저장해둔 백업에서 데이터를 메모리로 복구

이러한 이유로 실제 서비스에서는 보통 일반적인 데이터베이스와 함께 Redis를 사용해서 각자의 장점을 살리는 방식으로 운영한다고 합니다.

## **Redis와 데이터베이스를 함께 사용하는 다양한 패턴**

1. Write-Through 패턴
    1. 애플리케이션이 직접 Redis와 데이터베이스를 모두 업데이트.
    2. 데이터의 일관성이 중요할 때 사용함 → 은행 계좌 잔액 같은 중요한 정보를 다룰 때 유용함.
    3. 모든 쓰기 작업이 두 번 일어나서 약간의 성능 저하가 있음.
2. Write-Behind 패턴
    1. 먼저 Redis에만 데이터를 쓰고, 나중에 일괄적으로 데이터베이스에 동기화함.
    2. 실시간 분석이나 로그 수집 등 높은 쓰기 처리량이 많을 때 사용함 → 사용자의 페이지 조회 기록을 저장할 때 유용함.
3. Refresh-Ahead 패턴
    1. 시스템이 데이터 접근 패턴을 예측해서 미리 캐시를 갱신함.
    2. 예측 가능한 데이터 접근 패턴이 있을 때 유용함 → SNS에서 사용자가 로그인하면 해당 사용자의 피드를 미리 캐시에 로드해둠
4. Event Sourcing 패턴
    1. Redis를 이벤트 스트림 저장소로 사용하고 데이터베이스는 최종 상태를 저장함.
    2. 시스템의 모든 상태 변화를 기록해야 할 때 유용함 → 주문 처리 시스템이나 재고 관리 시스템
5. Cache-Aside 패턴
    1. 메인 데이터베이스와 별개로 Redis에 있는 캐시가 보조적인 역할을 수행함
    2. 애플리케이션은 항상 먼저 캐시를 확인 → 캐시가 없으면 데이터베이스 조회, 그리고 그 결과를 캐시에 저장
    3. 가장 널리 사용되는 패턴 → 구현이 단순함, 캐시와 데이터베이스의 역할이 구분됨, 캐시가 실패해도 시스템은 멈추지 않음, 메모리 효율성

### **보완적인 기술 → Cache Warming**

캐시 관리 전략중 하나인데 다른 패턴들과 함께 사용되는 기술입니다.

예를 들어, 대형 쇼핑몰 서비스를 운영한다고 가정하고, 매일 아침 9시에 새로운 특가 상품이 올라오고, 수많은 고객이(수천 명) 한꺼번에 접속함. 이때 캐시가 비어있다면(콜드 캐시)? → 바로 데이터베이스 과부하

그래서 특가가 시작하기 전에 미리 데이터를 캐시에 로드해주는 작업을 하는게 캐시 워밍입니당.

하지만 고려할 점은

- 워밍할 데이터의 선정: 모든 데이터를 미리 캐시할 수는 없으므로, 중요하고 자주 사용되는 데이터를 선별해야함.
- 워밍 시점의 결정: 너무 일찍 데이터를 캐시하면 그 사이에 데이터가 변경될 수 있고, 너무 늦으면 준비가 미처 끝나지 않을 수 있음.
- 리소스 사용: 캐시 워밍 과정 자체가 시스템에 부하를 줄 수 있으므로, 적절한 시점과 속도로 진행해야 함.

## **Redis가 빠른 이유**

1. 데이터를 메모리에 저장하기에 디스크 I/O가 발생하지 않아서 빠릅니다. 실제 접근 시간을 보면, 메모리는 약 100 나노초, 디스크는 약 10 밀리초가 걸림.
2. 단순하고 최적화된 데이터 구조를 사용함. 또한 Redis는 내부적으로 특별한 인코딩 방식을 사용하여 데이터를 저장함.

```bash
# Redis의 최적화된 데이터 구조 예시
# 작은 정수의 경우 (예: 카운터)
INCR user:123:visits  # 정수 인코딩 사용, 매우 빠름

# 큰 데이터의 경우
SET user:123:profile "{큰 JSON 데이터}"  # 일반 문자열 인코딩 사용
```

1. 단일 스레드로 동작해서 컨텍스트 스위칭 오버헤드가 없음.
2. Redis는 네트워크 통신에서 자체 프로토콜을 사용해서 데이터 전송을 최적화하고, 메모리 할당을 효율적으로 관리하기 위해 jemalloc이라는 특별한 메모리 할당자를 사용함

## **사용 가능한 주요 컬렉션과 활용 사례**

1. String
    1. 간단한 키-값 저장, 카운터, 세션 관리 등에 사용됨.
    2. 예) 사용자 세션 정보나 캐시된 웹페이지 데이터를 저장할 때 활용됨.
2. List
    1. 메세지 큐, 최근 활동 로그, 소셜 미디어 피드 등을 구현할 때 사용.
    2. 특히 실시간 피드 시스템이나 작업 대기열을 구현할 때 유용함.
3. Set
    1. 친구 목록, 중복 제거가 필요한 데이터 등을 저장할 때 사용됨.
4. Hash
    1. 사용자 프로필이나 제품 정보와 같은 객체 데이터를 저장할 때 사용됨.
5. Sorted Set
    1. 리더보드, 실시간 랭킹, 우선순위 큐 등을 구현할 때 사용됨.

## **Redis와 Memcached의 주요 차이점**

Redis는 메모리에 저장하는 방식이라 Memcached와 비슷하다고 생각할 수 있지만 차이가 있습니다.

1. 데이터 구조
    1. Redis는 방금 말씀드린 데이터 구조처럼 다양한 구조를 지원하지만, Memcached는 단순한 키-값 저장만 지원함.
2. 영속성
    1. Redis는 데이터를 디스크에 저장할 수 있는 옵션을 제공하지만, Memcached는 순수 인메모리 캐시로 작동함.
3. 복제
    1. Redis는 복제를 지원하지만 Memcached는 기본적으로 복제를 지원하지 않음.
4. 메모리 관리
    1. Redis의 메모리 관리 방식은 Memcached보다 훨신 복잡한 방식을 사용해서 가상 메모리를 지원함.

### **메모리 관리**

1. Memcached의 메모리 관리 방식
- 단순한 slab allocation 방식을 사용함.
- 메모리를 고정된 크기로 나누어 관리하는 방식.
- 예를 들어 1MB의 메모리가 있다면 이를 1KB의 크기로 나누어 데이터를 저장함.

1. Redis의 메모리 관리 방식
    1. 동적 메모리 할당: jemalloc이라는 메모리 할당자를 사용함. 데이터의 크기에 따라 동적으로 메모리를 할당할 수 있다.
    2. 가상 메모리 지원: Redis는 모든 데이터를 RAM에 저장하지만 덜 사용되는 데이터는 디스크로 옮길 수 있다.
    3. maxmemory-policy: 해당 설정을 통해 메모리가 부족하면 어떤 데이터를 삭제할지 정할 수 있음

이러한 복잡한 메모리 관리 덕분에 Redis는 더 효율적으로 메모리를 사용하고, 더 큰 데이터들을 처리하며, 상황에 맞게 유연하게 메모리를 관리할 수 있다.

```bash
# 1GB RAM만 있는 서버에서
# Memcached: 1GB 이상의 데이터를 저장할 수 없음
# Redis: 가상 메모리를 통해 2GB의 데이터를 관리할 수 있음
#        (자주 사용하는 1GB는 RAM에, 덜 사용하는 1GB는 디스크에 저장)
```

## **결론: 왜 Redis를 사용하는걸까?**

- 성능 향상
- 실시간 데이터 처리
- 세션 관리
- 일시적 데이터 보관


### 오늘의 회고
이름은 들어봤지만 실제로 어떻게 작동을 하는지는 몰랐는데 알아서 재밌었다.